From 43dfb08aa6e053bcf1cf5696ea6bc3b9b2aa3d53 Mon Sep 17 00:00:00 2001
Message-Id: <43dfb08aa6e053bcf1cf5696ea6bc3b9b2aa3d53.1527544850.git.Jim.Somerville@windriver.com>
In-Reply-To: <b6ceef1c915827b50ce3f76da4dc47f3eb768b44.1527544850.git.Jim.Somerville@windriver.com>
References: <b6ceef1c915827b50ce3f76da4dc47f3eb768b44.1527544850.git.Jim.Somerville@windriver.com>
From: Kam Nasim <kam.nasim@windriver.com>
Date: Wed, 4 Oct 2017 14:02:10 -0400
Subject: [PATCH 23/26] US103091: IMA: System Configuration

Normally (if trusted integrity keyring is disabled), the _ima keyring
needs to be created by user space (specifically systemd), but that has
the added disadvantage of requiring the IMA public key to reside on the
file system as opposed to being compiled in. Somebody could render some
serious Grade A damage by corrupting this public key on the FS.
Crippling the system if IMA 'enforce' action is enabled.

We will therefore create the IMA keyring inside the kernel and load the
IMA public key as a compiled data blob, similar to how the Kernel loads
trusted X509 keys into the system truststore (.system_keyring)

Signed-off-by: Jim Somerville <Jim.Somerville@windriver.com>
Signed-off-by: Zhang Zhiguo <zhangzhg@neusoft.com>

---
 certs/.gitignore              |  1 +
 certs/Makefile                | 45 +++++++++++++++++++-
 certs/ima_certificate.S       | 20 +++++++++
 certs/system_keyring.c        | 80 +++++++++++++++++++++++++++++++++++
 include/keys/system_keyring.h |  2 +
 5 files changed, 146 insertions(+), 2 deletions(-)
 create mode 100644 certs/ima_certificate.S

diff --git a/certs/.gitignore b/certs/.gitignore
index f51aea4..3396b4a 100644
--- a/certs/.gitignore
+++ b/certs/.gitignore
@@ -2,3 +2,4 @@
 # Generated files
 #
 x509_certificate_list
+ima_x509_certificate
diff --git a/certs/Makefile b/certs/Makefile
index 5d0999b..3e868ea 100644
--- a/certs/Makefile
+++ b/certs/Makefile
@@ -3,7 +3,7 @@
 # Makefile for the linux kernel signature checking certificates.
 #
 
-obj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o
+obj-$(CONFIG_SYSTEM_TRUSTED_KEYRING) += system_keyring.o system_certificates.o ima_certificate.o
 obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist.o
 ifneq ($(CONFIG_SYSTEM_BLACKLIST_HASH_LIST),"")
 obj-$(CONFIG_SYSTEM_BLACKLIST_KEYRING) += blacklist_hashes.o
@@ -29,7 +29,48 @@ $(obj)/x509_certificate_list: scripts/extract-cert $(SYSTEM_TRUSTED_KEYS_SRCPREF
 	$(call if_changed,extract_certs,$(SYSTEM_TRUSTED_KEYS_SRCPREFIX)$(CONFIG_SYSTEM_TRUSTED_KEYS))
 endif # CONFIG_SYSTEM_TRUSTED_KEYRING
 
-clean-files := x509_certificate_list .x509.list
+###############################################################################
+#
+# We will roll in the IMA X.509 certificate and pull it in the kernel
+# so that it gets loaded into the _ima keyring during boot.
+#
+# Ideally, this should have been treated similar to other .x509 certificates
+# (X509_CERTIFICATES), but those all get loaded into the system trusted keyring
+# and since the canonical pathnames are not available in the x509_certificate_list
+# compiled data blob, there is no way to isolate the IMA certificate from the
+# rest. Therefore we treat the IMA certificate as a seperate blob all together.
+#
+# We look in the source root for the IMA certificate, of name "ima_signing_key.pub"
+#
+###############################################################################
+IMA_X509_CERTIFICATE := $(srctree)/ima_signing_key.pub
+
+ifneq ($(wildcard $(obj)/.x509.ima),)
+ifneq ($(shell cat $(obj)/.x509.ima),$(IMA_X509_CERTIFICATE))
+$(info IMA: X.509 certificate changed)
+$(shell rm $(obj)/.x509.ima)
+endif
+endif
+
+# GCC doesn't include .incbin files in -MD generated dependencies (PR#66871)
+$(obj)/ima_certificate.o: $(obj)/ima_x509_certificate
+
+# Cope with signing_key.x509 existing in $(srctree) not $(objtree)
+AFLAGS_ima_certificate.o := -I$(IMA_X509_CERTIFICATE)
+
+quiet_cmd_extract_certs  = EXTRACT_CERTS   $(patsubst "%",%,$(2))
+      cmd_extract_certs  = scripts/extract-cert $(2) $@ || ( rm $@; exit 1)
+
+targets += ima_x509_certificate
+$(obj)/ima_x509_certificate: scripts/extract-cert $(SYSTEM_TRUSTED_KEYS_SRCPREFIX)$(SYSTEM_TRUSTED_KEYS_FILENAME) FORCE
+	$(call if_changed,extract_certs,$(SYSTEM_TRUSTED_KEYS_SRCPREFIX)$(CONFIG_SYSTEM_TRUSTED_KEYS))
+
+targets += $(obj)/.x509.ima
+$(obj)/.x509.ima:
+	@echo $(IMA_X509_CERTIFICATE) >$@
+
+
+clean-files := x509_certificate_list .x509.list ima_x509_certificate .x509.ima
 
 ifeq ($(CONFIG_MODULE_SIG),y)
 ###############################################################################
diff --git a/certs/ima_certificate.S b/certs/ima_certificate.S
new file mode 100644
index 0000000..f163630
--- /dev/null
+++ b/certs/ima_certificate.S
@@ -0,0 +1,20 @@
+#include <linux/export.h>
+#include <linux/init.h>
+
+    __INITRODATA
+
+    .align 8
+    .globl VMLINUX_SYMBOL(ima_system_certificate)
+VMLINUX_SYMBOL(ima_system_certificate):
+__cert_list_start:
+    .incbin "certs/ima_x509_certificate"
+__cert_list_end:
+
+    .align 8
+    .globl VMLINUX_SYMBOL(ima_system_certificate_size)
+VMLINUX_SYMBOL(ima_system_certificate_size):
+#ifdef CONFIG_64BIT
+    .quad __cert_list_end - __cert_list_start
+#else
+    .long __cert_list_end - __cert_list_start
+#endif
diff --git a/certs/system_keyring.c b/certs/system_keyring.c
index 19bd050..02d7a8b 100644
--- a/certs/system_keyring.c
+++ b/certs/system_keyring.c
@@ -27,10 +27,15 @@ static struct key *secondary_trusted_keys;
 #ifdef CONFIG_INTEGRITY_PLATFORM_KEYRING
 static struct key *platform_trusted_keys;
 #endif
+struct key *ima_keyring;
+EXPORT_SYMBOL_GPL(ima_keyring);
 
 extern __initconst const u8 system_certificate_list[];
 extern __initconst const unsigned long system_certificate_list_size;
 
+extern __initconst const u8 ima_system_certificate[];
+extern __initconst const unsigned long ima_system_certificate_size;
+
 /**
  * restrict_link_to_builtin_trusted - Restrict keyring addition by built in CA
  *
@@ -126,6 +131,25 @@ static __init int system_trusted_keyring_init(void)
 	if (key_link(secondary_trusted_keys, builtin_trusted_keys) < 0)
 		panic("Can't link trusted keyrings\n");
 #endif
+	/* Normally (if trusted integrity keyring is disabled), the _ima
+	 * keyring needs to be created by user space but that has the
+	 * added disadvantage of requiring the IMA public key to reside on
+	 * the file system as opposed to being compiled in.
+	 * We will therefore form a _ima keyring here and load build
+	 * the IMA X.509 certificate
+     *
+     * N.B: The IMA keyring only allows root userspace view & read ops
+	 */
+	pr_notice("Initializing system IMA keyring\n");
+
+	ima_keyring = keyring_alloc("_ima",
+				KUIDT_INIT(0), KGIDT_INIT(0),
+				current_cred(),
+				((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+				KEY_USR_VIEW | KEY_USR_READ | KEY_USR_SEARCH),
+				KEY_ALLOC_NOT_IN_QUOTA, NULL, NULL);
+	if (IS_ERR(ima_keyring))
+		panic("Can't allocate system IMA keyring\n");
 
 	return 0;
 }
@@ -191,6 +215,62 @@ dodgy_cert:
 }
 late_initcall(load_system_certificate_list);
 
+/*
+ * Load the compiled-in IMA certificate.
+ */
+static __init int load_ima_system_certificate(void)
+{
+	key_ref_t key;
+	const u8 *p, *end;
+	size_t plen;
+
+	pr_notice("Loading compiled-in X.509 IMA certificate\n");
+
+	p = ima_system_certificate;
+	end = p + ima_system_certificate_size;
+	while (p < end) {
+		/* Each cert begins with an ASN.1 SEQUENCE tag and must be more
+		 * than 256 bytes in size.
+		 */
+		if (end - p < 4)
+			goto dodgy_cert;
+		if (p[0] != 0x30 &&
+		    p[1] != 0x82)
+			goto dodgy_cert;
+		plen = (p[2] << 8) | p[3];
+		plen += 4;
+		if (plen > end - p)
+			goto dodgy_cert;
+
+		key = key_create_or_update(make_key_ref(ima_keyring, 1),
+					   "asymmetric",
+					   NULL,
+					   p,
+					   plen,
+					   ((KEY_POS_ALL & ~KEY_POS_SETATTR) |
+					   KEY_USR_VIEW | KEY_USR_READ),
+					   KEY_ALLOC_NOT_IN_QUOTA |
+					   KEY_ALLOC_BUILT_IN);
+		if (IS_ERR(key)) {
+			pr_err("Problem loading in-kernel X.509 certificate (%ld)\n",
+			       PTR_ERR(key));
+		} else {
+			set_bit(KEY_FLAG_BUILTIN, &key_ref_to_ptr(key)->flags);
+			pr_notice("Loaded X.509 cert '%s'\n",
+				  key_ref_to_ptr(key)->description);
+			key_ref_put(key);
+		}
+		p += plen;
+	}
+
+	return 0;
+
+dodgy_cert:
+	pr_err("Problem parsing in-kernel X.509 IMA certificate\n");
+	return 0;
+}
+late_initcall(load_ima_system_certificate);
+
 #ifdef CONFIG_SYSTEM_DATA_VERIFICATION
 
 /**
diff --git a/include/keys/system_keyring.h b/include/keys/system_keyring.h
index c7f899e..4f757a7 100644
--- a/include/keys/system_keyring.h
+++ b/include/keys/system_keyring.h
@@ -73,4 +73,6 @@ static inline void set_platform_trusted_keys(struct key *keyring)
 
 #endif /* CONFIG_INTEGRITY_PLATFORM_KEYRING */
 
+extern struct key *ima_keyring;
+
 #endif /* _KEYS_SYSTEM_KEYRING_H */
-- 
2.18.1

